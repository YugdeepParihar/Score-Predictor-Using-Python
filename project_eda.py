# -*- coding: utf-8 -*-
"""Project EDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QYZCZQNR8tMN8-_LyxNag6YX_O0c9Fex
"""



import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

data=pd.read_excel('ipl.xlsx')

data.head()
# this will show starting 5 rows from the dataset

data.isnull()
#

data.notnull()
#

data.fillna(method='pad') # this method will replace null value with previous one.

# Now we will apply EDA on the given dataset 

######################## First Business Moment Decision ##################################
#######################Measure of Central Tendency############################################
# mean
# mode
# median

data.mean()

data.median()

data.mode()

######################## Second Business Moment Decision ##################################
####################### Measure of Spread ############################################
# var
# std
# max
# quantile

data.var()

data.std()

print(data['total'].max())
print(data['total'].min())

data.quantile()

data.describe()

######################## Third Business Moment Decision ##################################
####################### Skewness  ########################################################

data['total'].skew()

# negatively skewed (also known as left-skewed) distribution is
# a type of distribution in which more values are concentrated on the right side (tail) of the 
# distribution graph while the left tail of the distribution graph is longer

a=data.total.unique()
a

plt.hist(data.total.unique()) #histogram

######################## Fourth Business Moment Decision ##################################
####################### Kurtosis  #######################################################

data.kurt()
# Kurtosis refers to the degree of presence of outliers in the distribution.
#  Kurtosis is a statistical measure, whether the data is heavy-tailed or light-tailed in a normal distribution

sns.boxplot(data.total)

print("Highest allowed",data['total'].mean() + 3*data['total'].std()) 
# maximum threshold
print("Lowest allowed",data['total'].mean() - 3*data['total'].std())
# minimum threshold

a=data[(data['total'] <73) | (data['total'] >248)]
a.shape
# we Will use trimming as dataset is too large
# we have found 425 raws that are outliers

print(data.shape)
df=data[(data['total'] > 75) & (data['total'] < 248)]
print(df.shape)

sns.boxplot(df.total)

temp=df.sample(50) # we make a temporary dataframe with the help of sample function
#  that halp to take random values from whole dataset.

plt.figure(1,figsize=(16,10))
sns.countplot(temp['total'] )
# frequency = countplot

plt.figure(1,figsize=(8,6))
plt.bar(temp['total'] ,temp['overs'])

sns.jointplot(x=temp['total'],y=temp['overs'])

from scipy import stats
import pylab

stats.probplot(temp.total, dist = "norm", plot = pylab)
plt.show()

sns.pairplot(temp.iloc[:, :])

sns.lineplot(data = temp, x = "overs", y = "runs")

temp1=df.sample(15)
sns.heatmap(temp1.loc[: ,["striker", "non-striker"]])
# The primary purpose of Heat Maps is to better visualize 
# the volume of locations/events within a dataset and assist in directing viewers 
# towards areas on data visualizations that matter most

############################### Correlation ########################################
# Correlation measures the relationship between two variables. We mentioned that
#  a function has a purpose to predict a value, by converting input (x) to output (f(x)).
#  We can say also say that a function uses the relationship between two variables for prediction

np.corrcoef(temp.total,temp.overs)
plt.scatter(y=temp.total,x=temp.overs,color='purple')

df.corr()

# we see there exists low collinearity between input variables 
# so no collinearity problem




















